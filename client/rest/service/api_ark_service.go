/*


No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: version not set
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ArkServiceAPIService ArkServiceAPI service
type ArkServiceAPIService service

type ApiArkServiceConfirmRegistrationRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	confirmRegistrationRequest *ConfirmRegistrationRequest
}

func (r ApiArkServiceConfirmRegistrationRequest) ConfirmRegistrationRequest(confirmRegistrationRequest ConfirmRegistrationRequest) ApiArkServiceConfirmRegistrationRequest {
	r.confirmRegistrationRequest = &confirmRegistrationRequest
	return r
}

func (r ApiArkServiceConfirmRegistrationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ArkServiceConfirmRegistrationExecute(r)
}

/*
ArkServiceConfirmRegistration Method for ArkServiceConfirmRegistration

ConfirmRegistration allows a client that has been selected for the next batch to confirm its
participation by revealing the intent id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceConfirmRegistrationRequest
*/
func (a *ArkServiceAPIService) ArkServiceConfirmRegistration(ctx context.Context) ApiArkServiceConfirmRegistrationRequest {
	return ApiArkServiceConfirmRegistrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ArkServiceAPIService) ArkServiceConfirmRegistrationExecute(r ApiArkServiceConfirmRegistrationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceConfirmRegistration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/batch/ack"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.confirmRegistrationRequest == nil {
		return localVarReturnValue, nil, reportError("confirmRegistrationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.confirmRegistrationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceDeleteIntentRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	deleteIntentRequest *DeleteIntentRequest
}

func (r ApiArkServiceDeleteIntentRequest) DeleteIntentRequest(deleteIntentRequest DeleteIntentRequest) ApiArkServiceDeleteIntentRequest {
	r.deleteIntentRequest = &deleteIntentRequest
	return r
}

func (r ApiArkServiceDeleteIntentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ArkServiceDeleteIntentExecute(r)
}

/*
ArkServiceDeleteIntent Method for ArkServiceDeleteIntent

DeleteIntent removes a previously registered intent from the server.
The client should provide the BIP-322 signature and message including any of the vtxos used in
the registered intent to prove its ownership.
The server should delete the intent and return success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceDeleteIntentRequest
*/
func (a *ArkServiceAPIService) ArkServiceDeleteIntent(ctx context.Context) ApiArkServiceDeleteIntentRequest {
	return ApiArkServiceDeleteIntentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ArkServiceAPIService) ArkServiceDeleteIntentExecute(r ApiArkServiceDeleteIntentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceDeleteIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/batch/deleteIntent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteIntentRequest == nil {
		return localVarReturnValue, nil, reportError("deleteIntentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteIntentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceEstimateIntentFeeRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	estimateIntentFeeRequest *EstimateIntentFeeRequest
}

func (r ApiArkServiceEstimateIntentFeeRequest) EstimateIntentFeeRequest(estimateIntentFeeRequest EstimateIntentFeeRequest) ApiArkServiceEstimateIntentFeeRequest {
	r.estimateIntentFeeRequest = &estimateIntentFeeRequest
	return r
}

func (r ApiArkServiceEstimateIntentFeeRequest) Execute() (*EstimateIntentFeeResponse, *http.Response, error) {
	return r.ApiService.ArkServiceEstimateIntentFeeExecute(r)
}

/*
ArkServiceEstimateIntentFee Method for ArkServiceEstimateIntentFee

EstimateIntentFee allows to estimate the fees for a given intent.
The client should provide a BIP-322 message with the same data as the register intent message,
and the server should respond with the estimated fees in satoshis.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceEstimateIntentFeeRequest
*/
func (a *ArkServiceAPIService) ArkServiceEstimateIntentFee(ctx context.Context) ApiArkServiceEstimateIntentFeeRequest {
	return ApiArkServiceEstimateIntentFeeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EstimateIntentFeeResponse
func (a *ArkServiceAPIService) ArkServiceEstimateIntentFeeExecute(r ApiArkServiceEstimateIntentFeeRequest) (*EstimateIntentFeeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EstimateIntentFeeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceEstimateIntentFee")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/batch/estimateFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.estimateIntentFeeRequest == nil {
		return localVarReturnValue, nil, reportError("estimateIntentFeeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.estimateIntentFeeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceFinalizeTxRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	finalizeTxRequest *FinalizeTxRequest
}

func (r ApiArkServiceFinalizeTxRequest) FinalizeTxRequest(finalizeTxRequest FinalizeTxRequest) ApiArkServiceFinalizeTxRequest {
	r.finalizeTxRequest = &finalizeTxRequest
	return r
}

func (r ApiArkServiceFinalizeTxRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ArkServiceFinalizeTxExecute(r)
}

/*
ArkServiceFinalizeTx Method for ArkServiceFinalizeTx

FinalizeTx is the last lef of the process of spending vtxos offchain and allows a client to
submit the fully signed checkpoint txs for the provided Ark txid .
The server verifies the signed checkpoint transactions and returns success if everything is
valid.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceFinalizeTxRequest
*/
func (a *ArkServiceAPIService) ArkServiceFinalizeTx(ctx context.Context) ApiArkServiceFinalizeTxRequest {
	return ApiArkServiceFinalizeTxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ArkServiceAPIService) ArkServiceFinalizeTxExecute(r ApiArkServiceFinalizeTxRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceFinalizeTx")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tx/finalize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.finalizeTxRequest == nil {
		return localVarReturnValue, nil, reportError("finalizeTxRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.finalizeTxRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceGetEventStreamRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	topics *[]string
}

func (r ApiArkServiceGetEventStreamRequest) Topics(topics []string) ApiArkServiceGetEventStreamRequest {
	r.topics = &topics
	return r
}

func (r ApiArkServiceGetEventStreamRequest) Execute() (*GetEventStreamResponse, *http.Response, error) {
	return r.ApiService.ArkServiceGetEventStreamExecute(r)
}

/*
ArkServiceGetEventStream Method for ArkServiceGetEventStream

GetEventStream is a server-side streaming RPC that allows clients to receive a stream of
events related to batch processing.
Clients should use this stream as soon as they are ready to join a batch and can listen for
various events such as batch start, batch finalization, and other related activities.
The server pushes these events to the client in real-time as soon as its ready to move to the
next phase of the batch processing. Upon creation of the stream, the event StreamStartedEvent
is immediately sent, which passes along the stream id, to be used by the client for future
calls to UpdateStreamTopics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceGetEventStreamRequest
*/
func (a *ArkServiceAPIService) ArkServiceGetEventStream(ctx context.Context) ApiArkServiceGetEventStreamRequest {
	return ApiArkServiceGetEventStreamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetEventStreamResponse
func (a *ArkServiceAPIService) ArkServiceGetEventStreamExecute(r ApiArkServiceGetEventStreamRequest) (*GetEventStreamResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEventStreamResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceGetEventStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/batch/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.topics != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "topics", r.topics, "simple", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceGetInfoRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
}

func (r ApiArkServiceGetInfoRequest) Execute() (*GetInfoResponse, *http.Response, error) {
	return r.ApiService.ArkServiceGetInfoExecute(r)
}

/*
ArkServiceGetInfo Method for ArkServiceGetInfo

GetInfo returns information and parameters of the server.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceGetInfoRequest
*/
func (a *ArkServiceAPIService) ArkServiceGetInfo(ctx context.Context) ApiArkServiceGetInfoRequest {
	return ApiArkServiceGetInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetInfoResponse
func (a *ArkServiceAPIService) ArkServiceGetInfoExecute(r ApiArkServiceGetInfoRequest) (*GetInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceGetInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceGetPendingTxRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	getPendingTxRequest *GetPendingTxRequest
}

func (r ApiArkServiceGetPendingTxRequest) GetPendingTxRequest(getPendingTxRequest GetPendingTxRequest) ApiArkServiceGetPendingTxRequest {
	r.getPendingTxRequest = &getPendingTxRequest
	return r
}

func (r ApiArkServiceGetPendingTxRequest) Execute() (*GetPendingTxResponse, *http.Response, error) {
	return r.ApiService.ArkServiceGetPendingTxExecute(r)
}

/*
ArkServiceGetPendingTx Method for ArkServiceGetPendingTx

GetPendingTx returns not finalized transaction(s) for a given set of inputs.
the client should provide a BIP322 proof of ownership of the inputs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceGetPendingTxRequest
*/
func (a *ArkServiceAPIService) ArkServiceGetPendingTx(ctx context.Context) ApiArkServiceGetPendingTxRequest {
	return ApiArkServiceGetPendingTxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetPendingTxResponse
func (a *ArkServiceAPIService) ArkServiceGetPendingTxExecute(r ApiArkServiceGetPendingTxRequest) (*GetPendingTxResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPendingTxResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceGetPendingTx")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tx/pending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getPendingTxRequest == nil {
		return localVarReturnValue, nil, reportError("getPendingTxRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getPendingTxRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceGetTransactionsStreamRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
}

func (r ApiArkServiceGetTransactionsStreamRequest) Execute() (*GetTransactionsStreamResponse, *http.Response, error) {
	return r.ApiService.ArkServiceGetTransactionsStreamExecute(r)
}

/*
ArkServiceGetTransactionsStream Method for ArkServiceGetTransactionsStream

GetTransactionsStream is a server-side streaming RPC that allows clients to receive
notifications in real-time about any commitment tx or ark tx processed and finalized by the
server.
NOTE: the stream doesn't have history support, therefore returns only txs from the moment it's
opened until it's closed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceGetTransactionsStreamRequest
*/
func (a *ArkServiceAPIService) ArkServiceGetTransactionsStream(ctx context.Context) ApiArkServiceGetTransactionsStreamRequest {
	return ApiArkServiceGetTransactionsStreamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTransactionsStreamResponse
func (a *ArkServiceAPIService) ArkServiceGetTransactionsStreamExecute(r ApiArkServiceGetTransactionsStreamRequest) (*GetTransactionsStreamResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTransactionsStreamResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceGetTransactionsStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/txs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceRegisterIntentRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	registerIntentRequest *RegisterIntentRequest
}

func (r ApiArkServiceRegisterIntentRequest) RegisterIntentRequest(registerIntentRequest RegisterIntentRequest) ApiArkServiceRegisterIntentRequest {
	r.registerIntentRequest = &registerIntentRequest
	return r
}

func (r ApiArkServiceRegisterIntentRequest) Execute() (*RegisterIntentResponse, *http.Response, error) {
	return r.ApiService.ArkServiceRegisterIntentExecute(r)
}

/*
ArkServiceRegisterIntent Method for ArkServiceRegisterIntent

RegisterIntent allows to register a new intent that will be eventually selected by the server
for a particular batch.
The client should provide a BIP-322 message with the intent information, and the server should
respond with an intent id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceRegisterIntentRequest
*/
func (a *ArkServiceAPIService) ArkServiceRegisterIntent(ctx context.Context) ApiArkServiceRegisterIntentRequest {
	return ApiArkServiceRegisterIntentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RegisterIntentResponse
func (a *ArkServiceAPIService) ArkServiceRegisterIntentExecute(r ApiArkServiceRegisterIntentRequest) (*RegisterIntentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RegisterIntentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceRegisterIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/batch/registerIntent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.registerIntentRequest == nil {
		return localVarReturnValue, nil, reportError("registerIntentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.registerIntentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceSubmitSignedForfeitTxsRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	submitSignedForfeitTxsRequest *SubmitSignedForfeitTxsRequest
}

func (r ApiArkServiceSubmitSignedForfeitTxsRequest) SubmitSignedForfeitTxsRequest(submitSignedForfeitTxsRequest SubmitSignedForfeitTxsRequest) ApiArkServiceSubmitSignedForfeitTxsRequest {
	r.submitSignedForfeitTxsRequest = &submitSignedForfeitTxsRequest
	return r
}

func (r ApiArkServiceSubmitSignedForfeitTxsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ArkServiceSubmitSignedForfeitTxsExecute(r)
}

/*
ArkServiceSubmitSignedForfeitTxs Method for ArkServiceSubmitSignedForfeitTxs

SubmitSignedForfeitTxs allows a client to submit signed forfeit transactions and/or signed
commitment transaction (in case of onboarding).
The server should verify the signed txs and return success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceSubmitSignedForfeitTxsRequest
*/
func (a *ArkServiceAPIService) ArkServiceSubmitSignedForfeitTxs(ctx context.Context) ApiArkServiceSubmitSignedForfeitTxsRequest {
	return ApiArkServiceSubmitSignedForfeitTxsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ArkServiceAPIService) ArkServiceSubmitSignedForfeitTxsExecute(r ApiArkServiceSubmitSignedForfeitTxsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceSubmitSignedForfeitTxs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/batch/submitForfeitTxs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitSignedForfeitTxsRequest == nil {
		return localVarReturnValue, nil, reportError("submitSignedForfeitTxsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitSignedForfeitTxsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceSubmitTreeNoncesRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	submitTreeNoncesRequest *SubmitTreeNoncesRequest
}

func (r ApiArkServiceSubmitTreeNoncesRequest) SubmitTreeNoncesRequest(submitTreeNoncesRequest SubmitTreeNoncesRequest) ApiArkServiceSubmitTreeNoncesRequest {
	r.submitTreeNoncesRequest = &submitTreeNoncesRequest
	return r
}

func (r ApiArkServiceSubmitTreeNoncesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ArkServiceSubmitTreeNoncesExecute(r)
}

/*
ArkServiceSubmitTreeNonces Method for ArkServiceSubmitTreeNonces

SubmitTreeNonces allows a cosigner to submit the tree nonces for the musig2 session of a given
batch.
The client should provide the batch id, the cosigner public key, and the tree nonces.
The server should verify the cosigner public key and the nonces, and store them for later
aggregation once nonces from all clients are collected.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceSubmitTreeNoncesRequest
*/
func (a *ArkServiceAPIService) ArkServiceSubmitTreeNonces(ctx context.Context) ApiArkServiceSubmitTreeNoncesRequest {
	return ApiArkServiceSubmitTreeNoncesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ArkServiceAPIService) ArkServiceSubmitTreeNoncesExecute(r ApiArkServiceSubmitTreeNoncesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceSubmitTreeNonces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/batch/tree/submitNonces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitTreeNoncesRequest == nil {
		return localVarReturnValue, nil, reportError("submitTreeNoncesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitTreeNoncesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceSubmitTreeSignaturesRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	submitTreeSignaturesRequest *SubmitTreeSignaturesRequest
}

func (r ApiArkServiceSubmitTreeSignaturesRequest) SubmitTreeSignaturesRequest(submitTreeSignaturesRequest SubmitTreeSignaturesRequest) ApiArkServiceSubmitTreeSignaturesRequest {
	r.submitTreeSignaturesRequest = &submitTreeSignaturesRequest
	return r
}

func (r ApiArkServiceSubmitTreeSignaturesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ArkServiceSubmitTreeSignaturesExecute(r)
}

/*
ArkServiceSubmitTreeSignatures Method for ArkServiceSubmitTreeSignatures

SubmitTreeSignatures allows a cosigner to submit the tree signatures for the musig2 session of
a given batch.
The client should provide the batch id, the cosigner public key, and the tree signatures.
The server should verify the cosigner public key and the signatures, and store them for later
aggregation once signatures from all clients are collected.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceSubmitTreeSignaturesRequest
*/
func (a *ArkServiceAPIService) ArkServiceSubmitTreeSignatures(ctx context.Context) ApiArkServiceSubmitTreeSignaturesRequest {
	return ApiArkServiceSubmitTreeSignaturesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ArkServiceAPIService) ArkServiceSubmitTreeSignaturesExecute(r ApiArkServiceSubmitTreeSignaturesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceSubmitTreeSignatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/batch/tree/submitSignatures"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitTreeSignaturesRequest == nil {
		return localVarReturnValue, nil, reportError("submitTreeSignaturesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitTreeSignaturesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceSubmitTxRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	submitTxRequest *SubmitTxRequest
}

func (r ApiArkServiceSubmitTxRequest) SubmitTxRequest(submitTxRequest SubmitTxRequest) ApiArkServiceSubmitTxRequest {
	r.submitTxRequest = &submitTxRequest
	return r
}

func (r ApiArkServiceSubmitTxRequest) Execute() (*SubmitTxResponse, *http.Response, error) {
	return r.ApiService.ArkServiceSubmitTxExecute(r)
}

/*
ArkServiceSubmitTx Method for ArkServiceSubmitTx

SubmitTx is the first leg of the process of spending vtxos offchain and allows a client to
submit a signed Ark transaction and the unsigned checkpoint transactions.
The server should verify the signed transactions and return the fully signed Ark tx and the
signed checkpoint txs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceSubmitTxRequest
*/
func (a *ArkServiceAPIService) ArkServiceSubmitTx(ctx context.Context) ApiArkServiceSubmitTxRequest {
	return ApiArkServiceSubmitTxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitTxResponse
func (a *ArkServiceAPIService) ArkServiceSubmitTxExecute(r ApiArkServiceSubmitTxRequest) (*SubmitTxResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitTxResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceSubmitTx")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tx/submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitTxRequest == nil {
		return localVarReturnValue, nil, reportError("submitTxRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitTxRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiArkServiceUpdateStreamTopicsRequest struct {
	ctx context.Context
	ApiService *ArkServiceAPIService
	updateStreamTopicsRequest *UpdateStreamTopicsRequest
}

func (r ApiArkServiceUpdateStreamTopicsRequest) UpdateStreamTopicsRequest(updateStreamTopicsRequest UpdateStreamTopicsRequest) ApiArkServiceUpdateStreamTopicsRequest {
	r.updateStreamTopicsRequest = &updateStreamTopicsRequest
	return r
}

func (r ApiArkServiceUpdateStreamTopicsRequest) Execute() (*UpdateStreamTopicsResponse, *http.Response, error) {
	return r.ApiService.ArkServiceUpdateStreamTopicsExecute(r)
}

/*
ArkServiceUpdateStreamTopics Method for ArkServiceUpdateStreamTopics

UpdateStreamTopics allows a client to modify the topics of their event stream. They can add,
remove, or specify a list of topics, providing them control over the events received on the
event stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiArkServiceUpdateStreamTopicsRequest
*/
func (a *ArkServiceAPIService) ArkServiceUpdateStreamTopics(ctx context.Context) ApiArkServiceUpdateStreamTopicsRequest {
	return ApiArkServiceUpdateStreamTopicsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateStreamTopicsResponse
func (a *ArkServiceAPIService) ArkServiceUpdateStreamTopicsExecute(r ApiArkServiceUpdateStreamTopicsRequest) (*UpdateStreamTopicsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateStreamTopicsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArkServiceAPIService.ArkServiceUpdateStreamTopics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/batch/updateTopics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateStreamTopicsRequest == nil {
		return localVarReturnValue, nil, reportError("updateStreamTopicsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateStreamTopicsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Status
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
