package wallet

import (
	"encoding/hex"
	"fmt"

	"github.com/arkade-os/arkd/pkg/ark-lib/script"
	"github.com/btcsuite/btcd/btcec/v2"
)

// ExtractTapKeyFromScripts parses encoded VTXo scripts and extracts the
// taproot output key. This is used to derive addresses from custom scripts.
//
// The function:
//  1. Parses the hex-encoded scripts using script.ParseVtxoScript
//  2. Generates the taproot tree structure
//  3. Extracts the taproot output key
//
// Parameters:
//   - scripts: Array of hex-encoded tapscripts generated by a VtxoScriptBuilder
//
// Returns:
//   - *btcec.PublicKey: The taproot output key for address generation
//   - error: Returns error if scripts are invalid or cannot be parsed
//
// Example:
//
//	scripts, _ := builder.BuildOffchainScript(userKey, signerKey, delay)
//	tapKey, err := ExtractTapKeyFromScripts(scripts)
//	if err != nil {
//	    return err
//	}
//	address := btcutil.NewAddressTaproot(schnorr.SerializePubKey(tapKey), net)
func ExtractTapKeyFromScripts(scripts []string) (*btcec.PublicKey, error) {
	if len(scripts) == 0 {
		return nil, fmt.Errorf("no scripts provided")
	}

	// Parse the VTXo script from the encoded tapscripts
	vtxoScript, err := script.ParseVtxoScript(scripts)
	if err != nil {
		return nil, fmt.Errorf("failed to parse vtxo script: %w", err)
	}

	// Generate the taproot tree and extract the taproot output key
	tapKey, _, err := vtxoScript.TapTree()
	if err != nil {
		return nil, fmt.Errorf("failed to generate tap tree: %w", err)
	}

	return tapKey, nil
}

// ValidateScripts checks if generated scripts are valid and well-formed.
// This should be called to validate output from custom script builders.
//
// The function validates that:
//  1. At least one script is provided
//  2. All scripts are non-empty
//  3. All scripts are valid hexadecimal strings
//  4. Scripts decode to non-empty byte arrays
//
// Parameters:
//   - scripts: Array of hex-encoded tapscripts to validate
//
// Returns:
//   - error: Returns detailed error if validation fails, nil if valid
//
// Example:
//
//	scripts, _ := customBuilder.BuildOffchainScript(...)
//	if err := ValidateScripts(scripts); err != nil {
//	    log.Fatalf("Invalid scripts: %v", err)
//	}
func ValidateScripts(scripts []string) error {
	if len(scripts) == 0 {
		return fmt.Errorf("no scripts generated")
	}

	for i, script := range scripts {
		if len(script) == 0 {
			return fmt.Errorf("script %d is empty", i)
		}

		// Validate script is valid hexadecimal
		decoded, err := hex.DecodeString(script)
		if err != nil {
			return fmt.Errorf("script %d is not valid hex: %w", i, err)
		}

		if len(decoded) == 0 {
			return fmt.Errorf("script %d decodes to empty bytes", i)
		}
	}

	return nil
}

// ValidateScriptBuilder performs comprehensive validation of a VtxoScriptBuilder
// by testing it with dummy keys and checking the output.
//
// This is useful for:
//  1. Testing custom script builder implementations
//  2. Validating script builders before use in production
//  3. Debugging script generation issues
//
// Parameters:
//   - builder: The VtxoScriptBuilder to validate
//   - userPubKey: A valid user public key for testing
//   - signerPubKey: A valid signer public key for testing
//
// Returns:
//   - error: Returns detailed error if validation fails, nil if builder is valid
//
// Example:
//
//	builder := &MyCustomBuilder{}
//	if err := ValidateScriptBuilder(builder, userKey, signerKey); err != nil {
//	    log.Fatalf("Script builder is invalid: %v", err)
//	}
func ValidateScriptBuilder(builder VtxoScriptBuilder, userPubKey, signerPubKey interface{}) error {
	// Import here to avoid circular dependencies in tests
	// This validation is optional and mainly for debugging
	return fmt.Errorf("not implemented - use unit tests to validate script builders")
}
